from langgraph.graph import StateGraph, START, END
from langgraph.prebuilt import ToolNode
from langchain_core.messages import BaseMessage, HumanMessage
from typing import Annotated, Sequence, TypedDict
from langgraph.graph.message import add_messages
from langchain_core.tools import tool
from PIL import Image, ImageDraw, ImageFont
import textwrap
from supabase import create_client
from langchain_community.document_loaders import WebBaseLoader
from langchain_core.messages import SystemMessage
from dotenv import load_dotenv
import os
import requests
from langchain_groq import ChatGroq
import random
from moviepy import AudioFileClip, ImageClip
import time
import google.auth.transport.requests
from google.oauth2.credentials import Credentials
from googleapiclient.discovery import build
from googleapiclient.http import MediaFileUpload
from datetime import datetime
from zoneinfo import ZoneInfo

load_dotenv()


class AgentState(TypedDict):
    messages: Annotated[Sequence[BaseMessage], add_messages]

def get_authenticated_service():
    creds = Credentials(
        token=None,
        refresh_token=os.getenv("YT_REFRESH_TOKEN"),
        token_uri="https://oauth2.googleapis.com/token",
        client_id=os.getenv("YT_CLIENT_ID"),
        client_secret=os.getenv("YT_CLIENT_SECRET"),
        scopes=["https://www.googleapis.com/auth/youtube.upload"]
    )
    creds.refresh(google.auth.transport.requests.Request())
    return build("youtube", "v3", credentials=creds)

def upload_youtube_video(file_path):
    youtube = get_authenticated_service()

    request_body = {
        "snippet": {
            "title":"Headlines",
            "description":"Latest headlines automatically generated by AI",
            "tags":['Shorts','News','IndianNews'],
            "categoryId": "22", 
        },
        "status": {
            "privacyStatus": "public",
        }
    }

    media = MediaFileUpload(file_path, chunksize=-1, resumable=True)

    request = youtube.videos().insert(
        part="snippet,status",
        body=request_body,
        media_body=media
    )
    response = request.execute()
    print("Uploaded:", response["id"])


@tool
def make_post_video(
    news_summary: str,
    font_path: str = "Lexend.ttf",
    font_size: int = 30,
    text_color: str = "black",
    padding: int = 60,
    line_spacing: float = 1.5,
    max_text_width: int = 1290,
    post_size: tuple = (1080, 1350),
):
    """
    Helps in creating a video to post on instagram by passing the text in the post
    Args:
        news_summary: summary of latest news obtained

    Returns:
        Path to created video
    """
    bg_colors = [
        "#F04A00",
        "#F6DE16",
        "#5E5CB2",
        "#94D2BD",
        "#E9D8A6",
        "#BDB76B",
        "#8FBC8B",
        "#FFF8DC",
        "#FFFFFF",
        "#F0E68C",
        "#F0FFF0",
        "#F5FFFA",
        "#F0FFFF",
        "#F0F8FF",
        "#DFFF00",
        "#F5F5F5",
        "#FFF0F5",
        "#FFE4E1",
        "#E1AFD1",
        "#A7D7C5",
        "#ADA2FF",
        "#ECFAE5",
        "#FFE1FF",
    ]
    image_bg = random.choice(bg_colors)
    img = Image.new("RGB", post_size, color=image_bg)
    draw = ImageDraw.Draw(img)
    points = news_summary.split("\n")

    try:
        fonts = [
            "RobotoSlab.ttf"
        ]
        font_path = "fonts/" + random.choice(fonts)
        font = ImageFont.truetype(font_path, font_size)
        headline_font = ImageFont.truetype(font_path,45)
        date_font = ImageFont.truetype(font_path,25)
    except OSError:
        print(f"Font {font_path} not found, using default font")
        font = ImageFont.load_default()
        headline_font = ImageFont.load_default()
        date_font = ImageFont.load_default()

    dummy_img = Image.new("RGB", (1, 1))
    dummy_draw = ImageDraw.Draw(dummy_img)
    avg_char_width = (
        sum(dummy_draw.textlength(c, font=font) for c in "ABCDEFGHIJKLMNOPQRSTUVWXYZ")
        / 26
    )
    max_chars_per_line = max_text_width // avg_char_width
    lines = []

    for i in points:
        lines.extend(textwrap.wrap(i, width=int(max_chars_per_line)))
        lines.extend([""])

    base_line_height = font.getbbox("A")[3] - font.getbbox("A")[1]
    line_height = int(base_line_height * line_spacing)

    y = padding - 30
    draw.text((770, y), "theNewsGuyBot", font=font, fill=text_color)
    draw.text((771, y + 1), "theNewsGuyBot", font=font, fill=text_color)
    draw.text((769, y - 1), "theNewsGuyBot", font=font, fill=text_color)
    dateString = '/'.join(reversed(str(datetime.now(ZoneInfo('Asia/Kolkata')).date()).split('-')))
    timeString = str(datetime.now(ZoneInfo('Asia/Kolkata')).strftime('%I:%M %p')) + " IST"
    dayString = str(datetime.now(ZoneInfo('Asia/Kolkata')).strftime("%A"))
    draw.text((770, y+line_height),dateString , font=date_font, fill=text_color)
    
    draw.text((770, y+1.8*line_height),timeString , font=date_font, fill=text_color)
    y += line_height
    draw.text((padding, y),dayString+ " Headlines", font=headline_font, fill=text_color)
    draw.text((padding + 1, y + 1),dayString + " Headlines", font=headline_font, fill=text_color)
    draw.text((padding - 1, y - 1),dayString + " Headlines", font=headline_font, fill=text_color)

    y += 2.5 * line_height
    for line in lines:
        draw.text((padding, y), line, font=font, fill=text_color)
        y += line_height
    image_path = os.path.abspath("insta_text_post.png")
    img.save(image_path)
    print(f"Image saved at: {image_path}")
    audio_files = ['1.mp3','2.mp3','3.mp3','4.mp3','5.mp3','6.mp3','7.mp3','8.mp3','9.mp3']
    audio_path = 'audio/' + random.choice(audio_files)
    video_path = "insta_text_post.mp4"
    audio_clip = AudioFileClip(audio_path).subclipped(0,8)
    img_clip = ImageClip(image_path,duration=8)
    img_clip.audio = audio_clip
    img_clip.write_videofile(video_path,fps=30,codec='libx264',audio_codec="aac")
    print(f"Video saved at: {video_path}")
    os.remove(image_path)
    print("Uploading video to youtube...")
    upload_youtube_video(os.path.abspath(video_path))
    return os.path.abspath(video_path)


@tool
def upload_video_to_supabase(video_path: str):
    """Uploads video to supabase bucket instagram-posts as video.mp4
    Args:
        video_path: Video path in local directory
    returns:
        public_url: url of uploaded video

    """
    url = os.getenv("SUPABASE_URL")
    key = os.getenv("SUPABASE_ANON_KEY")

    if not url or not key:
        raise ValueError(
            "SUPABASE_URL and SUPABASE_ANON_KEY must be set in environment variables"
        )

    supabase = create_client(url, key)

    bucket_name = "instagram-posts"

    if not os.path.exists(video_path):
        raise FileNotFoundError(f"Image file not found at path: {video_path}")

    with open(video_path, "rb") as f:
        file_data = f.read()

    try:
        result = supabase.storage.from_(bucket_name).upload(
            "video.mp4", file_data, {"upsert": "true"}
        )
        print(f"Upload result: {result}")
    except Exception as e:
        print(f"Upload error: {e}")
        raise e

    public_url = supabase.storage.from_(bucket_name).get_public_url("video.mp4")

    try:
        os.remove(video_path)
        print(f"Local file removed: {video_path}")
    except OSError as e:
        print(f"Warning: Could not remove local file {video_path}: {e}")

    return public_url.strip("?")


@tool
def fetch_news():
    """Extracts latest Indian news from news sources and returns string of news content extracted"""
    try:
        news_sources = str(os.getenv("NEWS_SOURCES")).split("|")
        url = os.getenv("SUPABASE_URL")
        key = os.getenv("SUPABASE_ANON_KEY")
        supabase = create_client(url,key) #type:ignore
        idx = supabase.from_('NewsSourceCounter').select("counter").execute().data[0]['counter']
        idx = (idx + 1) % 10
        news_source = news_sources[idx]
        supabase.from_("NewsSourceCounter").update({"counter":idx}).eq("id",1).execute()
        loader = WebBaseLoader(news_source)
        docs = loader.load()
        return docs[0].page_content
    except Exception as e:
        print(f"Error fetching news: {e}")
        raise e


def create_container_for_post(video_url: str):
    instagram_id = os.getenv("INSTAGRAM_ID")
    instagram_access_token = os.getenv("INSTAGRAM_ACCESS_TOKEN")

    if not instagram_id or not instagram_access_token:
        raise ValueError(
            "INSTAGRAM_ID and INSTAGRAM_ACCESS_TOKEN must be set in environment variables"
        )

    url = f"https://graph.instagram.com/v23.0/{instagram_id}/media?media_type=REELS&video_url={video_url}&share_to_feed=TRUE&caption=Headlines %23BreakingNews %23NewsUpdate %23DailyNews %23NewsAlert %23InstaNews %23NewsBot %23AInews %23AINewsBot %23AutomatedNews %23TechNews %23IndiaNews %23BharatNews %23DeshKiKhabar %23TrendingInIndia %23IndianNews %23DelhiNews %23MumbaiNews %23HyderabadNews %23AIContent %23AIAutomation %23AIforGood %23Langchain %23GPTpowered %23AIrevolution %23AgenticAI %23ViralReels %23InstaDaily %23ExplorePage %23FYP&access_token={instagram_access_token}"
    res = requests.post(url)
    data = res.json()

    if "id" not in data:
        raise KeyError(f"Instagram API error: {data}")
    
    graph_url = "https://graph.instagram.com/v23.0/"
    def status_of_upload(ig_container_id = data['id'],access_token=instagram_access_token):
        url = graph_url + ig_container_id
        param = {}
        param['access_token'] = access_token
        param['fields'] = 'status_code'
        response = requests.get(url,params=param)
        response = response.json()
        return response
    
    while(status_of_upload()['status_code']=="IN_PROGRESS"):
        time.sleep(5)

    return data["id"]


@tool
def create_instagram_post(supabase_video_url: str):
    """Creates an instagram post
    Args:
        supabase_video_url: public URL of video in supabase
    returns:
        id: id of uploaded post
    """
    try:
        creation_id = create_container_for_post(supabase_video_url)
        instagram_id = os.getenv("INSTAGRAM_ID")
        instagram_access_token = os.getenv("INSTAGRAM_ACCESS_TOKEN")

        url = f"https://graph.instagram.com/v23.0/{instagram_id}/media_publish?creation_id={creation_id}&access_token={instagram_access_token}"
        res = requests.post(url)
        data = res.json()

        if "id" not in data:
            raise KeyError(f"Instagram publish API error: {data}")

        return data["id"]
    except Exception as e:
        print(f"Error creating Instagram post: {e}")
        raise e


tools = [fetch_news, make_post_video, upload_video_to_supabase, create_instagram_post]
os.environ["GROQ_API_KEY"] = os.getenv("GROQ_API_KEY")  # type:ignore
llm = ChatGroq(model="meta-llama/llama-4-maverick-17b-128e-instruct").bind_tools(
    tools=tools
)


def journalist_agent(state: AgentState) -> AgentState:
    system_prompt = SystemMessage(
        content="""
    You are a journalist who posts news on instagram. You must call tools one at a time in the correct sequence:
    1. First call fetch_news() to get the latest news
    2. Then analyze the news and create a 8 point plain text summary where each point must be self explanatory with reader understandability
    3. Call make_post_video() with the actual summary text
    4. Call upload_video_to_supabase() with the actual video path returned from make_post_video
    5. Finally call create_instagram_post() with the actual Supabase URL returned from upload_video_to_supabase
    
    Never call multiple tools at once. Wait for each tool's response before proceeding to the next step.
    Always use the actual return values from previous tools, not placeholder text.
    
    If you have already fetched news, proceed to create a summary and call make_post_video.
    If you have created a video, proceed to upload it to supabase.
    If you have uploaded to supabase, proceed to create the instagram post.
    Continue until all steps are complete.
    """
    )

    response = llm.invoke([system_prompt] + state["messages"])  # type:ignore

    print(f"LLM Response: {response.content}")
    if hasattr(response, "tool_calls") and response.tool_calls:  # type:ignore
        print(
            f"Tool calls: {[call['name'] for call in response.tool_calls]}" #type:ignore
        )  # type:ignore

    return {"messages": [response]}


def should_go_to_tools(state: AgentState):
    messages = state["messages"]

    if not messages:
        return "stop"

    last_message = messages[-1]

    if (
        hasattr(last_message, "tool_calls") and len(last_message.tool_calls) > 0 #type:ignore
    ):  # type:ignore
        return "continue"
    return "stop"


graph = StateGraph(AgentState)

graph.add_node("llm", journalist_agent)
graph.add_node("tools", ToolNode(tools=tools))

graph.add_edge(START, "llm")
graph.add_edge("tools", "llm")


graph.add_conditional_edges(
    "llm", should_go_to_tools, {"continue": "tools", "stop": END}
)

agent = graph.compile()


def run_agent():
    """Helper function to run the agent with better error handling"""
    try:
        response = agent.invoke(
            {
                "messages": [
                    HumanMessage(
                        content="""Summarize the most latest news from internet into 8 point wise plain text summary where each point must be self explanatory with reader understandability. 
                                            Create a video with the summary generated. 
                                            Upload that video to supabase.
                                            Use the supabase public url to upload the video to instagram.
                                            Use all the relevant tools available with you. Follow the steps one by one."""
                    )
                ]
            }
        )
        return response
    except Exception as e:
        print(f"Error running agent: {e}")
        return None


if __name__ == "__main__":
    response = run_agent()
    if response:
        print("\nFinal Response:")
        print(response)
    else:
        print("Agent execution failed.")
